#### 의사코드 설계 연습방법
- 첫번째. 프로그램의 논리를 설명하고 알고리즘을 표현하기 위해 작성한 일종의 지침이다
  - 원칙 1: 프로그래밍 언어로 작성하면 안된다.
  - 원칙 2: 일반인도 이해할 수 있는 자연어로 작성한다.
  - 원칙 3: 일정한 형식이 없다.(자유롭다)
- 두번째. 의사 코드가 완성되면 이를 토대로 코드를 구현 할것이므로 의사 코드는 문제 해결 순서대로 작성한다.
- 세번째. 구현 전 마지막 단계는 충분히 테스트한다.


#### Big-Oh 시간복잡도 순서
순서: 𝑂(1) < 𝑂(log n) < 𝑂(n) < 𝑂(nlog n) < 𝑂(n^2) < 𝑂(n^3) < 𝑂(2^n) < 𝑂(n!)

일반적으로 알고리즘의 평균적인 시간이 의미가 없는 경우가 많아서 Big-Oh 표기법이 주로 사용된다.

#### 브루트포스(brute force)
- 문제를 해결하기 위해 가능한 모든 경우의 수를 탐색하면서 요구조건에 충족되는 결과만을 가져온다.(완전 탐색 알고리즘)
- 선형 구조를 전체적으로 탐색하는 순차탐색
  - 리스트에서 특정한 값을 찾는 알고리즘이다.
  - 리스트에서 찾고자하는 값을 맨 앞에서 부터 끝까지 찾아 나가는 것이다.
  - 검색할 리스트의 길이가 길면 비효율적이지만, 검색 방법 중 가장 단순하여 구현이 쉽다.
  - 정렬되지 않은 리스트에서도 사용 할 수 있다.
- 비선형 구조를 전체적으로 탐색하는 깊이 우선 탐색(DFS - Depth First Search)과 너비 우선 탐색(BFS - Breadth First Depth)

#### 정렬
- 선택정렬(Selection Sort)
  - 배열이 끝날때까지 첫번째 자리에 가장 작은 값을 넣고, 그 뒤 두번째 자리에 그 다음 작은 값을 선택해서 넣는다. 배열이 끝날때까지 반복한다.
- 버블정렬(Bubble Sort)
  - 현재 배열요소와 그 다음 배열 요소를 비교한 다음 조건에 맞으면 교환하는 방식의 정렬이다.
- 삽입정렬(Insertion Sort)
  - 현재 비교하고자 하는 타겟과 그 이전의 원소들과 비교하여 자리를 교환하는 방법이다.
  - 삽입 정렬의 전체적인 과정은 아래와 같다.
    1. 현재 타겟이 되는 숫자와 이전 위치에 있는 원소들과 비교한다.(첫 번째 타겟은 두 번째 원소부터 시작한다.)
    2. 타겟이 되는 숫자가 이전 위치에 있던 원소보다 작으면 위치를 서로 교환한다.
    3. 그 다음 타겟을 찾아 위와 같은 방법으로 반복한다.
- 셸 정렬(Shell Sort)
  - 삽입 정렬을 보완한 알고리즘이다.
  - 삽입 정렬이 어느 정도 정렬된 배열에 대해서는 대단히 빠른것에 착안
  - 과정
    1. 정렬해야 할 리스트의 각 k 번째 요소를 추출해서 부분 리스트를 만든다. 이때 k를 간격(gap)이라고 한다.
        - 간격의 초깃값: (정렬할 값의 수) / 2
        - 생성된 부분 리스트의 갯수는 gap과 같다.
    2. 각 회전마다 간격 k를 절반으로 줄인다. 즉, 각 회전이 반복될 때마다 하나의 부분 리스트에 속한 값들의 개수는 증가한다.
        - 간격은 홀수로 하는 것이 좋다.
        - 간격을 절반으로 줄일 때 짝수가 나오면 +1을 해서 홀수로 만든다.
    3. 간격 k 가 1이 될 때까지 반복한다.
- 퀵 정렬(Quick Sort)
  - 다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬에 속한다.
  - 평균적으로 매우 빠른 수행 속도를 자랑하는 정렬 방법이다.
  - 과정
    1. 리스트 안에 있는 한 요소를 선택한다. 이 원소를 피벗(pivot)이라고 한다.
    2. 피벗을 기준으로 피벗보다 작은 요소들은 피벗의 왼쪽으로 옮겨지고, 피벗보다 큰 요소들은 피벗의 오른쪽으로 옮긴다.
    3. 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.
        - 분할된 부분 리스트에 대해서 순환호출을 이용하여 정렬을 반복한다.
        - 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복한다.
    4. 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.
- 힙 정렬(Heap Sort)
  - 최대 힙 트리나 최소 힙 트리를 구성해 정렬하는 방법이다.
  - 내림차순 정렬을 위해서는 최대 힙을 구성하고 오름차순 정렬을 위해서는 최소 힙을 구성하면 된다.
  - 과정
    1. 정렬해야 할 n개의 요소들로 최대 힙(완전 이진 트리 형태)을 만든다.
    2. 그 다음으로 한 번에 하나씩 요소를 힙에서 꺼내서 배열의 뒤부터 저장한다.
    3. 삭제되는 요소들(최댓값부터 삭제)은 값이 감소되는 순서로 정렬되게 된다.
- 합병 정렬(Merge Sort)
  - 일반적인 방법으로 구현했을 때 이 정렬은 안정 정렬에 속하며, 분할 정복 알고리즘의 하나이다.
  - 분할 정복이란 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략이다.
  - 분할 정복 방법은 대개 순환 호출을 이용하여 구현한다.
  - 과정
    1. 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는
    2. 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
    3. 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.
    4. 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.

#### 백트래킹(Backtracking)
- 퇴각검색
- 조건만족 즉, CSP(Constrain Satisfaction Problems)을 해결하기 위해 쓰인다.
- 모든 조합의 수를 살펴보는 것이지만 단, 조건이 만족할 때만이다.
- 반목문의 횟수까지 줄 일 수 있으므로 효율적이다.

#### 동적계획법(Dynamic Programming)
- 문제의 최적해를 구하거나 답의 개수를 세는 과정에 사용할 수 있는 알고리즘이다.
- 불필요한 계산을 줄이고, 효율적으로 최적해를 찾을 수 있다.
- 전체 문제를 작은 문제로 단순화한 다음 점화식으로 만들어 재귀적인 구조를 활용해서 전체 문제를 해결하는 방식이다.
  1. 전체 문제를 작은 문제로 단순화 한다. -> 부분 문제를 정의한다.
  2. 재귀적인 구조를 활용할 수 있는 점화식을 만든다. -> 점화식을 만든다.
  3. 작은 문제를 해결한 방법으로 전체 문제를 해결한다. -> 문제를 해결한다.
- 메모이제이션(Memoization): 함수의 값을 계산한 뒤 계산된 값을 배열에 저장하는 방식이다. 이렇게 하면 함수를 다시 호출하지 않고 값을 빠르게 가져 올 수 있다.
- Top-Down: 문제 풀이가 위에서 아래로 진행(메모이제이션 사용하는 방식)
- Bottom-Up: 문제 풀이가 아래에서 위로 진행(for 문을 이용해 처음값부터 계산해 나가는 방식)

#### 최장 증가 부분 수열(LIS, Longest Increasing Subsequence)
- 원소가 n개인 배열의 일부 원소를 골라내서 만든 부분 수열 중, 각 원소가 이전 원소보다 크다는 조건을 만족하고, 그 길이가 최대인 부분 수열을 최장 증가 부분 수열이라고 한다.
- 예. { 6, 2, 5, 1, 7, 4, 8, 3 } 배열인 경우, LIS는 { 2, 5, 7, 8 } 이 된다.

#### 탐욕(Greedy) 알고리즘
- 문제를 해결하는 과정에서 그 순간순간마다 최적이라고 생각되는 결정을 하는 방식으로 진행하여 최종 해답에 도달하는 문제 해결 방식이다.
- 순간순간마다의 최선의 결정이 전체 문제에서 최선의 해결책이 되지는 않는다.
- 이러한 단점들을 극복하는 탐욕법의 가장 큰 장점은 계산 속도이다.
- 활동 선택 문제(Activity Selection Problem)
  - 한 사람이 하나의 활동에 대해서만 작업할 수 있을 때 최대한 많은 활동을 할 수 있는 수를 선택하는 것이다.

#### 스택(Stack)
- 데이터를 쌓는 자료 구조이다.
- LIFO(Last In First Out)의 형태를 띈다.

#### 큐(Queue)
- FIFO(First In First Out)의 형태를 띈다.
- 데이터가 줄을 서는 자료 구조이다.
- 큐의 앞부분의 front는 삭제 연산만 가능하다.
- 큐의 뒷부분의 rear는 삽입 연산만 가능하다.

#### 덱(Deque)
- 앞뒤로 데이터를 넣을 수 있고 앞뒤로 데이터를 뺄 수 있다. 즉 양방향으로 넣고 뺄 수 있다.

#### 분할정복(Divide and Conquer)
- 문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘 이다.
- 설계 방법
  1. Divide: 문제가 분할이 가능한 경우, 2개 이상의 문제로 나눈다.
  2. Conquer: 나누어진 문제가 여전히 분할이 가능하다면 다시 Divide를 수행한다. 그렇지 않으면 문제를 푼다.
  3. Combine: Conquer 한 문제들을 통합하여 원래 문제의 답을 얻는다.
- 장점:
  - 문제를 나눔으로써 어려운 문제를 해결할 수 있다는 장점이 있다.
  - 병렬적으로 문제를 해결하는 장점이 있다.
- 단점:
  - 함수를 재귀적으로 호출한다는 점에서 함수 호출로 인한 오버헤드가 발생한다.
  - 스택에 다양한 데이터를 보관해야 하므로 스택 오버플로우가 발생한다.
  - 과도한 메모리를 사용하게 된다.

#### 쿼드트리(Quad Tree)
- 트리 자료구조 중 하나로 부모 노드 아래에 자식 노드를 4개씩 가지고 있는 트리이다.
- 이미지 용량, 충돌, 컬링 등 다양한 곳에서 최적화 기법으로 사용되고 있다.

#### 슈트라센 알고리즘(Strassen Algorithm)
- 행렬 곱셈 알고리즘이다.
- 정의에 따라 n * n 크기의 두 행렬을 곱하면 O(n3)의 시간이 소요되지만 이 알고리즘은 대략 O(n2.807)의 시간이 소요된다.
- 행렬을 가로/세로 절반으로 쪼개기 때문에, 행렬의 가로/세로 길이가 짝수여야 한다. 따라서 짝수로 만들기위해 0값을 적절하게 넣어줘야 한다.

#### 이분 탐색(Binary Search) 알고리즘
- 정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 방법이다.
- 배열 내부의 데이터가 정렬되어 있어야만 사용할 수 있다.
- Start, End, Mid 3가지 변수를 사용하여 탐색한다.
- 찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교해서 원하는 데이터를 찾는 것이다.

#### 우선순위 큐(Priority Queue)
- 들어간 순서에 상관없이 우선순위가 높은 데이터가 먼저 나오는 것이다.

#### 깊이 우선 탐색(Depth First Search)
- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식이다.
- 모든 노드를 방문하고자 하는 경우 이 방법을 선택한다.
- 검색 속도 자체는 너비 우선 탐색(BFS)에 비해서 느리다.
- 깊이 우선 탐색(DFS)이 너비 우선 탐색(BFS)보다 좀 더 간단하다.
- 모든 친구 관계를 다 살펴봐야 할지도 모른다.
- 스택 또는 재귀함수로 구현 한다.

#### 너비 우선 탐색(Breadth First Search)
- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법이다.
- 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.
- 가까운 관계부터 탐색한다.
- 큐를 이용하여 구현 한다.

#### 다익스트라 알고리즘(Dijkstra Algorithm)
- 동적계획법(Dynamic Programming)을 활용한 대표적인 최단 경로 탐색 알고리즘이다.
- 인공위성 GPS 소프트웨어 등에서 많이 사용 된다.
- 특정한 하나의 정점에서 다른 모든 정점으로 가는 최단 경로를 알려준다. 다만 이 때 음의 간선을 포함 할 수 없다. 음의 간선이 존재하지 않기 때문에 현실 세계에(현실세계에는 음의 간선이 존재 하지 않다.) 사용하기 매우 적합한 알고리즘 중 하나이다.
- 하나의 최단 거리를 구할 때 그 이전까지 구했던 최단 거리 정보를 그대로 사용 한다.

#### 벨만포드 알고리즘(Bellman Ford Algorithm)
- 한 노드에서 다른 노드까지의 최단거리를 구하는 알고리즘이다.
- 가중치가 음수 일 때도 사용 가능하다.
- 다익스트라 알고리즘에 비해 느리므로 가중치가 모두 양수 일 때는 굳이 사용 할 필요가 없다.
- 음의 값이 누적되는 사이클이 존재하는 경우, 의미 없는 값을 반환한다.
- 음수 사이클 판단 방법: 정점의 개수가 N인 경우, 최단 경로의 크기는 최대 |N| - 1 이 된다.(정점의 개수가 4, 최단 경로는 최대 3의 크기를 가짐) 즉, 사이클을 순환하여 최단 경로 크기가 커지는 것을 제한 한다.

#### 투 포인터 알고리즘(Two Pointers Algorithm)
- 1차원 배열에서 두 개의 포인터를 조작하여 원하는 결과를 얻는 알고리즘이다.
- 두 개의 포인터를 사용하여 기존의 방식보다 시간을 개선 할 수 있다.

#### 머클 트리(Merkle Tree)
- 머클 트리의 목적은 빠른 검색이 아닌, 데이터의 간편하고 확실한 인증을 위해 사용한다.
- 머클 트리의 최상위 부모노드는 머클 루트라 부르며 블록체인의 원소역할을 수행하는 블록에서 저장된 트랜잭션들의 해스 트리라고 볼 수 있다.
- 머클 트리는 수많은 거래 내용들을 해시함수를 통해 압축하고 인접한 노드끼리 더한 다음 다시 압축하는 과정을 반복해 나간다. 모든 결과 값은 이전 출력들을 해시함수를 거쳤기 때문에 입력이 하나라도 달라지면 최종결과인 머클 루트가 달라지게 된다.

#### 블룸 필터(Bloom Filter)
- 원소가 집합에 속하는지 여부를 검사하는데 사용되는 확률적 자료 구조이다.

#### 플로이드 와샬 알고리즘(Floyd Warshall Algorithm)
- 모든 정점에서 모든 정점으로의 최단 경로를 구하는 알고리즘이다.
- 거쳐가는 정점을 기준으로 최단 거리를 구하는 것이다.

#### 트라이(Trie)
- 문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조이다.
- 검색할 때 볼 수 있는 자동완성 기능, 사전 검색 등 문자열을 탐색하는데 특화되어 있는 자료구조이다.

#### 누적합(Prefix Sum, Cumulative Sum)
- 나열된 수의 누적된 합을 말한다.
- 대표적인 문제로 카운팅 정렬(Counting Sort), 구간 합 구하기가 존재한다.

#### H-Index
- H 지수는 특정 연구원의 연구 성과를 평가하기 위한 지표이다.
- 얼마나 많이 논문을 쓰는지 피인용수(Citation)가 많은 논문을 얼마나 썻는지를 기반으로 수치화 한것이다.
- H 지수 구하는 방법
  1. 피인용수를 기준으로 내림차순 정렬을 한다.
  2. 피인용수가 논문수와 같아지거나 피인용수가 논문수보다 작아지기 시작하는 숫자가 바로 나의 H 지수이다.
- 문제점
  - 학계에서 막 시작하는 유능한 사람에게는 높은 점수를 받기 어렵다.
  - 다른 분야별 통상적 피인용수 숫자에 대한 설명이 부족하다.
  - 제 1 저자, 제 2 저자 외 공동저자, 교신 저자를 동등한 위치에서 바라본다.
  - 자가 인용을 통해 조작이 가능하다.

#### 유니온 파인드(Union-Find)
- 대표적 그래프 알고리즘으로 '합집합 찾기'라는 의미를 가진다.
- 상호 배타적 집합(disjoint-set)이라고도 한다.
- 여러 노드가 존재할 때, 두 개의 노드를 선택해서, 현재 두 노드가 서로 같은 그래프에 속하는지 판별하는 알고리즘이다.
- 2가지 연산으로 이루어져 있다.
  1. Find: X가 어떤 집합에 포함되어 있는지 찾는 연산
  2. Union: X와 Y가 포함되어 있는 집합을 합치는 연산

#### 스패닝 트리(Spanning Tree)
- 그래프 내의 모든 정점을 포함하는 트리이다.
- 스패닝 트리 = 신장 트리
- 그래프의 최소 연결 부분 그래프이다.
  - 최소연결 = 간선의 수가 가장 적다.
  - n 개의 정점을 가지는 그래프의 최소 간선의 수는 (n - 1)개이고, (n - 1)개의 간선으로 연결되어 있으며 필연적으로 트리 형태가 되고 이것이 바로 스패닝 트리가 된다.
- 그래프에서 일부 간선을 선택해서 만든 트리이다.
- DFS, BFS를 이용하여 그래프에서 신장 트리를 찾을 수 있다.
  - 탐색 도중에 사용된 간선만 모으면 만들 수 있다.
- 하나의 그래프에는 많은 신장 트리가 존재할 수 있다.
- 트리의 특수한 형태이므로 모든 정점들이 연결 되어 있어야 하고 사이클을 포함해서는 안된다.
- 그래프에 있는 n 개의 정점을 정확히 (n - 1)개의 간선으로 연결한다.

#### 최소 스패닝 트리(MST - Minimum Spanning Tree)
- 최소 신장트리
- 각 간선의 가중치가 동일하지 않을 때 단순히 가장 적은 간선을 사용한다고 해서 최소 비용이 얻어지는 것은 아니다.
- MST는 간선에 가중치를 고려하여 최소 비용의 스패닝 트리를 선택하는 것이다.

